import React, { useMemo } from 'react';
import { Bot, Lightbulb, Activity, Stethoscope, FileText } from 'lucide-react';

// --- 1. 图标定义 ---
const AlertCardIcon = () => (
    <svg className="w-5 h-5 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
    </svg>
);

// --- 2. 核心指标词汇库 ---
const KNOWN_METRICS = [
    "Temperature", "Temp", "Humidity", "RH",
    "CO2", "CO₂", "PM2.5", "PM10", "IEQ", 
    "Illuminance", "Occupancy", "Spikes", "Noise", "VOC", 
    "Door events", "Notable hours", "Particles", "Ventilation"
];

// --- 3. 板块配置 ---
const SECTIONS_CONFIG = [
  { 
    id: 'findings', 
    title: 'Findings & Observations', 
    icon: <Activity className="w-5 h-5 text-blue-600" />, 
    regexKeywords: /findings|observations/i,
    style: 'bullet'
  },
  { 
    id: 'alarms', 
    title: 'Alarms & Anomalies', 
    icon: <AlertCardIcon />, 
    regexKeywords: /alarms|anomalies|spike/i,
    style: 'bullet'
  },
  { 
    id: 'diagnostics', 
    title: 'Diagnostics', 
    icon: <Stethoscope className="w-5 h-5 text-purple-600" />, 
    regexKeywords: /diagnostics|cause/i,
    style: 'card'
  },
  { 
    id: 'recommendations', 
    title: 'Recommendations', 
    icon: <Lightbulb className="w-5 h-5 text-amber-500" />, 
    regexKeywords: /recommendations|actions/i,
    style: 'numbered'
  },
];

interface LlmAnswerProps {
  answer: string;
}

export const LlmAnswer: React.FC<LlmAnswerProps> = ({ answer }) => {

  // --- 解析逻辑 ---
  const parsedContent = useMemo(() => {
    if (!answer) return {};

    const sectionPattern = /(?:^|\n)(?:#{1,6}|\*\*|\d+[\.\)]|-)?\s*(Findings|Observations|Alarms|Anomalies|Diagnostics|Cause|Recommendations|Actions)(?:.*?)[:\n]/gi;
    const matches = Array.from(answer.matchAll(sectionPattern));
    
    if (matches.length === 0) return { raw: answer };

    const result: Record<string, string> = {};
    matches.forEach((match, index) => {
      const keyword = match[1].toLowerCase();
      const startIndex = match.index! + match[0].length;
      const nextMatch = matches[index + 1];
      const endIndex = nextMatch ? nextMatch.index : answer.length;
      const content = answer.slice(startIndex, endIndex).trim();

      const config = SECTIONS_CONFIG.find(s => s.regexKeywords.test(keyword));
      if (config && content.length > 0) {
        result[config.id] = result[config.id] ? result[config.id] + '\n' + content : content;
      }
    });
    return result;
  }, [answer]);

  const isQuickAnswer = Object.keys(parsedContent).length === 0 || parsedContent.raw;

  return (
    <div className="bg-white rounded-xl shadow-lg border border-slate-100 overflow-hidden font-sans">
      {/* Header */}
      <div className="bg-blue-600 px-6 py-4 flex items-center gap-3 text-white">
        <Bot className="w-6 h-6" />
        <h2 className="text-lg font-bold tracking-wide">AI Analysis Report</h2>
      </div>
      
      <div className="p-6 grid gap-8">
        {!isQuickAnswer && SECTIONS_CONFIG.map((section) => {
            const content = parsedContent[section.id];
            if (!content) return null;

            return (
                <div key={section.id} className="relative">
                    <div className="flex items-center gap-2 mb-3">
                        {section.icon}
                        <h3 className="font-bold text-slate-800 text-base">{section.title}</h3>
                    </div>
                    <div className="pl-1">
                        {formatText(content, section.style as any)}
                    </div>
                </div>
            )
        })}
        
        {isQuickAnswer && (
            <div className="relative">
                <div className="flex items-center gap-2 mb-3">
                    <FileText className="w-5 h-5 text-slate-500" />
                    <h3 className="font-bold text-slate-800 text-base">Summary & Insights</h3>
                </div>
                <div className="pl-1">
                    {formatText(parsedContent.raw || answer, 'bullet')}
                </div>
            </div>
        )}
      </div>
      
      <div className="bg-slate-50 px-6 py-3 border-t border-slate-100 text-xs text-slate-400 text-right flex justify-between items-center">
         <span className="font-medium text-slate-400">Confidential Analysis</span>
         <span>Generated by IoT-LLM Agent</span>
      </div>
    </div>
  );
};

// --- 核心格式化引擎 ---

const formatText = (text: string, style: 'bullet' | 'numbered' | 'card' = 'bullet') => {
  if (!text) return null;
  const lines = text.split('\n').filter(line => line.trim() !== '');
  let listCounter = 0;

  return lines.map((line, idx) => {
    let cleanLine = line.trim();
    
    // 1. 移除列表符号和 Markdown 粗体标记 (如果它在行首)
    // 这样能确保 "**2025...**" 也能被正确识别
    if (/^[*-]\s/.test(cleanLine) || /^\d+[\.\)]\s/.test(cleanLine)) {
        cleanLine = cleanLine.replace(/^(?:[*-]|\d+[\.\)])\s+/, '');
    }
    // 移除行首的 Markdown 加粗符 (防止干扰日期检测)
    cleanLine = cleanLine.replace(/^\*\*/, '');

    // 2. 日期标题检测 (Pure Date Header)
    const rawCheck = cleanLine.replace(/[*_:]/g, '').trim();
    const isDateHeader = /^\d{4}-\d{2}-\d{2}/.test(rawCheck) && rawCheck.length < 15;

    // --- A. 提取【行尾】引用 (支持多个，且容忍末尾的句号/空格) ---
    let rightCitations: string[] = [];
    let contentPart = cleanLine;

    // 正则解释: 匹配行尾的 [xxx] 序列，允许后面跟句号(.)或空格
    const trailingPattern = /((?:\[[\d- :]+\](?:-[\[\d- :]+\])?(?:,\s*|\s+)*)+)[.\s]*$/;
    const tailMatch = cleanLine.match(trailingPattern);

    if (tailMatch) {
        const rawTail = tailMatch[1]; // 捕获引用部分 (不含句号)
        const individualCitations = rawTail.match(/\[[\d- :]+\](?:-[\[\d- :]+\])?/g);
        if (individualCitations) {
            rightCitations = individualCitations;
        }
        // 从正文中切除引用部分
        contentPart = cleanLine.substring(0, tailMatch.index).trim();
        // 如果切除后末尾有句号或逗号，根据美观度决定是否移除
        // 这里移除它，让引用显得更干净
        if (contentPart.endsWith('.') || contentPart.endsWith(',')) {
            contentPart = contentPart.slice(0, -1).trim();
        }
    }

    // --- B. 提取【行首】Key (Timestamp Capsule 逻辑) ---
    let keyPart = null;
    let isTimestampKey = false;

    // 支持 YYYY-MM-DD HH:mm-HH:mm: 格式 (包含 En-dash 或 Hyphen)
    // 同时也支持 wrap 在 Markdown 里的情况 (因为我们前面已经清理了开头的 **)
    const timestampKeyPattern = /^(\d{4}-\d{2}-\d{2}.*?\d{2}:\d{2})\**:/;
    const timestampMatch = contentPart.match(timestampKeyPattern);

    if (timestampMatch) {
        keyPart = timestampMatch[1].replace(/\*\*/g, ''); // 确保 Key 里没有残留的 **
        contentPart = contentPart.substring(timestampMatch[0].length).trim();
        isTimestampKey = true;
    } else {
        // 普通 Key (例如 "Note:", "CO2:")
        const generalKeyMatch = contentPart.match(/^([A-Za-z0-9 \(\)\.\-\/&,]+?):/);
        if (generalKeyMatch && generalKeyMatch[1].length < 60) {
            keyPart = generalKeyMatch[1];
            contentPart = contentPart.substring(generalKeyMatch[0].length).trim();
        }
    }

    // --- 渲染内容 ---
    const formattedBody = processInlineStyles(contentPart);

    const renderInnerContent = () => (
        <span className="text-slate-600 leading-7">
            {/* 1. Key 渲染 (Capsule or Bold) */}
            {keyPart && (
                isTimestampKey 
                ? <span className="inline-block bg-slate-100 text-slate-700 text-xs font-bold px-2 py-0.5 rounded border border-slate-200 mr-3 align-middle mb-0.5 shadow-sm whitespace-nowrap">{keyPart}</span>
                : <span className="font-bold text-slate-800 mr-1.5">{keyPart}:</span>
            )}
            
            {/* 2. 正文内容 */}
            {formattedBody}

            {/* 3. 行尾引用 (多个堆叠) */}
            {rightCitations.length > 0 && (
                <span className="float-right ml-2 flex flex-col items-end gap-1 mt-0.5">
                    {rightCitations.map((citation, cIdx) => (
                        <span key={cIdx} className="text-xs text-slate-400 font-medium bg-slate-50 px-1.5 py-0.5 rounded border border-slate-100 select-none whitespace-nowrap">
                            {citation}
                        </span>
                    ))}
                </span>
            )}
        </span>
    );

    // Case A: 纯日期标题
    if (isDateHeader) {
        return (
            <div key={idx} className="mt-5 mb-2 inline-block">
                <span className="text-sm font-bold text-slate-700 bg-slate-100 px-2 py-1 rounded border border-slate-200 shadow-sm">
                    {rawCheck}
                </span>
            </div>
        );
    }

    // Case B: 诊断卡片模式
    if (style === 'card') {
        return (
            <div key={idx} className="mb-3 p-3 bg-purple-50/40 rounded-lg border border-purple-100 hover:border-purple-200 transition-colors flex items-start gap-3 group">
                 <div className="mt-1.5 w-1 h-4 bg-purple-400 rounded-full flex-shrink-0 opacity-80" />
                 <div className="w-full">
                    {renderInnerContent()}
                 </div>
            </div>
        );
    }

    // Case C: 数字列表模式
    if (style === 'numbered') {
        listCounter++;
        return (
            <div key={idx} className="mb-2 pl-2 flex items-start gap-3 group">
                <span className="mt-0.5 flex items-center justify-center w-5 h-5 bg-amber-100 text-amber-700 text-xs font-bold rounded-full flex-shrink-0 border border-amber-200">
                    {listCounter}
                </span>
                <div className="w-full">
                    {renderInnerContent()}
                </div>
            </div>
        );
    }

    // Case D: 普通圆点列表
    return (
        <div key={idx} className="mb-2 pl-2 flex items-start gap-3 group">
             <span className="mt-2.5 w-1.5 h-1.5 bg-blue-400 rounded-full flex-shrink-0 opacity-80 shadow-sm" />
             <div className="w-full">
                {renderInnerContent()}
             </div>
        </div>
    );
  });
};

// --- 行内样式处理器 ---
const processInlineStyles = (text: string) => {
    const metricsPattern = KNOWN_METRICS.join('|').replace(/\./g, '\\.'); 

    const regex = new RegExp(
        `(\\*\\*.*?\\*\\*)|` +                         
        `\\b(${metricsPattern})(?:\\b|(?=[^a-zA-Z0-9]))|` + 
        `(CO₂)|` +
        // 数值高亮: 增加对 ≈, ~, > 等符号的支持
        `((?:≈|~|>=?|<=?|approx\\s)?\\d+(?:[\\-–]\\d+)?(?:\\.\\d+)?\\s?(?:ppm|µg\\/m³|lux|%|°C|C)?)|` +
        `\\b((?:median|mean|peak|min|max|score|val)\\s+\\d+(?:\\.\\d+)?)`, 
        'gi'
    );

    const parts = text.split(regex).filter(p => p !== undefined && p !== "");

    return parts.map((part, i) => {
        // 1. Markdown Bold
        if (part.startsWith('**') && part.endsWith('**')) {
            return <span key={i} className="font-bold text-slate-900">{part.slice(2, -2)}</span>;
        }

        // 2. Metrics (自动转换 CO2 -> CO₂)
        if (KNOWN_METRICS.some(m => m.toLowerCase() === part.toLowerCase()) || part === 'CO₂') {
            const display = part === 'CO2' ? <span>CO<sub>2</sub></span> : part;
            return <span key={i} className="font-bold text-slate-800">{display}</span>;
        }
        
        // 3. Values Highlighting
        const isValue = /\d/.test(part) && (
            part.includes('ppm') || part.includes('µg') || part.includes('%') || part.includes('°C') || part.includes('lux') ||
            part.includes('≈') || part.includes('~') || 
            /^\d/.test(part) 
        );

        if (isValue) {
             return <span key={i} className="font-semibold text-slate-800">{part}</span>;
        }
        
        // 4. Stat phrases (e.g., "median 66")
        if (/^(median|mean|peak|min|max|score|val)\s+\d+/.test(part.toLowerCase())) {
            const [stat, val] = part.split(/\s+/);
            return <span key={i}>{stat} <span className="font-semibold text-slate-800">{val}</span></span>;
        }

        return <span key={i}>{part}</span>;
    });
};

export default LlmAnswer;